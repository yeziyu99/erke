<!-- https://img.douyucdn.cn/data/yuba/weibo/2023/01/30/202301301644519310725438672.580x0.jpg -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        .banner_box {
            position: relative;
            width: 300px;
            height: 300px;
        }
        
        .banner_bg {
            background: url(https://img.douyucdn.cn/data/yuba/weibo/2023/01/30/202301301644519310725438672.580x0.jpg);
            width: 100%;
            height: 100%;
            background-repeat: no-repeat;
            background-size: cover;
            -webkit-filter: blur(15px);
            -moz-filter: blur(15px);
            -o-filter: blur(15px);
            -ms-filter: blur(15px);
            filter: blur(15px);
            position: absolute;
            left: 0;
            top: 0;
            /* height: 500px; */
        }
        
        .swiper-container {
            /* position: relative;
            top: 200px;
            left: 380px; */
            /* color: white;
            font-size: 36px;
            font-weight: 700;
            text-shadow: 0 2px 20px rgba(0, 0, 0, .1); */
        }
    </style>
</head>

<body>
    <div class="banner_box">
        <div class="banner_bg"></div>
        <div class="banner swiper-container">
            不模糊的内容
        </div>
    </div>
    <div class="banner_box">
        <div class="banner_bg"></div>
        <div class="banner swiper-container">
            不模糊的内容
        </div>
    </div>
    <div class="banner_box">
        <div class="banner_bg"></div>
        <div class="banner swiper-container">
            不模糊的内容
        </div>
    </div>
</body>

</html>
<!-- <!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .lyricPanel {
            width: 250px;
            height: 400px;
            border: 1px solid red;
            overflow-y: scroll;
        }
    </style>
</head>

<body>
    <div class="lyricPanel"></div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <script>

        ((w) => {
            let lyricFormat = function (lyric02) {
                let reg2 = /([[\d{2}:\d{2}\.\d{2,3}]+]+)(\n|.+)/g;
                let lyricUnformatedArray = [];
                res = reg2.exec(lyric02);
                while (res) {
                    lyricUnformatedArray.push({ time: res[1], lyric: res[2] });
                    res = reg2.exec(lyric02)
                }
                for (let i = 0; i < lyricUnformatedArray.length; i++) {
                    const element = lyricUnformatedArray[i];
                    if (element.lyric == "\n") {
                        if (lyricUnformatedArray[i + 1] != undefined && lyricUnformatedArray[i + 1].lyric == "\n") {
                            if (lyricUnformatedArray[i + 2].lyric == "\n") {
                                lyricUnformatedArray[i + 2] = { time: lyricUnformatedArray[i + 2].time, lyric: lyricUnformatedArray[i + 3].lyric }
                                lyricUnformatedArray[i] = { time: lyricUnformatedArray[i].time, lyric: lyricUnformatedArray[i + 3].lyric }
                            } else {
                                lyricUnformatedArray[i + 1] = { time: lyricUnformatedArray[i + 1].time, lyric: lyricUnformatedArray[i + 2].lyric }
                                lyricUnformatedArray[i] = { time: lyricUnformatedArray[i + 1].time, lyric: lyricUnformatedArray[i + 2].lyric }
                            }
                        } else {
                            if (lyricUnformatedArray[i + 1] != undefined) {
                                lyricUnformatedArray[i] = { time: element.time, lyric: lyricUnformatedArray[i + 1].lyric }
                            }
                        }
                    }
                }


                //把数组时间转换成秒
                let lyricFormated = [];
                for (let i = 0; i < lyricUnformatedArray.length; i++) {
                    let element = lyricUnformatedArray[i].time;
                    element = element.replaceAll("[", "").replaceAll("]", "");
                    element = element.split(".");
                    let nanoSecond = element[1];
                    let minutesAndSeconds = element[0];
                    minutesAndSeconds = minutesAndSeconds.split(":");
                    let minutes = minutesAndSeconds[0];
                    let seconds = minutesAndSeconds[1];
                    let musicSecond =
                        parseInt(minutes * 60) +
                        parseInt(seconds) +
                        parseFloat(nanoSecond / 1000);
                    lyricSentence = lyricUnformatedArray[i].lyric;
                    lyricFormated.push({ time: musicSecond, lyric: lyricSentence });
                }
                //进行数组排序
                function sortArray(n1, n2) {
                    return n1.time - n2.time;
                }
                lyricFormated.sort(sortArray)
                console.log(lyricFormated)
                return lyricFormated;
            };
            // let s = '[00:11.66]\r\n[01:47.03][00:14.99]你说我冷得像水仙\r\n[01:53.40][00:21.60]冬天才看到我的笑脸\r\n[02:00.99][00:29.26]你说我在等一个寓言\r\n[02:07.10][00:35.68]却永远不能够 不能够实现\r\n[02:13.54][00:42.00]\r\n[02:14.98][00:43.53]要为你改变 盛开在夏天\r\n[02:22.03][00:50.14]别忘了我就是水仙\r\n[02:25.26][00:53.58]白雪映出了 我的春天\r\n[03:03.54][02:31.41][00:59.75]\r\n[03:04.16][02:32.27][01:00.39]盛开在冬天的水仙\r\n[03:07.83][02:35.93][01:04.12]你是否闻得到我的娇艳\r\n[03:11.25][02:39.55][01:07.90]如果你给我一双舞鞋\r\n[03:14.70][02:42.93][01:11.34]我就会为你长袖翩翩\r\n[03:18.16][02:46.54][01:14.79]如果你看穿我的思念\r\n[03:21.77][02:50.02][01:18.33]我就不会为你哭红双眼\r\n[03:25.38][02:53.75][01:22.02]如果我能戒掉了思念\r\n[03:35.58][03:28.70][02:57.05][01:25.34]就不会开在你的窗前\r\n[03:46.24][01:32.18]'
            let s = '[00:36.00](若不是因为爱著你)\r\n[00:42.00]怎麼會夜深还没睡意\r\n[00:48.00]每个念头都关於你\r\n[00:54.00]我想你 想你 好想你\r\n[01:06.00](若不是因为爱著你)\r\n[01:12.00]怎麼有不安的情绪\r\n[01:18.00]每个莫名的日子里\r\n[01:23.00]我想你 想你 好想你\r\n[01:36.00][03:00.00]爱是折磨人的东西\r\n[01:42.00][03:06.00]却又不舍得这样放弃\r\n[01:48.00][03:12.00]不停偳测你的心理 可有我姓名\r\n[02:05.00][03:54.00](若不是因为爱著你)\r\n[02:12.00][04:00.00]怎麼會不经意就叹息\r\n[02:18.00][04:06.00]有种不完整的心情\r\n[02:24.00][04:11.00]爱你 爱你 (爱著你)\r\n[03:24.00]爱是我唯一的秘密\r\n[03:30.00]让人心碎却又著迷\r\n[03:36.00]无论是用什麼言语只會(只會)思念你'
            // lyricFormat(arr)
            function shiftTimeStamp(time) {
                // time /= 1000; 如果传进来的是 毫秒 形式，则在这里除1000将其转为 秒 形式
                function f_m_dispose(min, sec) { // 分秒处理函数
                    if (min < 10 && sec < 10) {
                        return "0" + min + ":" + "0" + sec; // 如果分和秒都小于10，则前面都加入0
                    } else if (min < 10 && sec >= 10) {
                        return "0" + min + ":" + sec; // 如果分小于10，秒大于10，则给分前面加0
                    } else if (min >= 10 && sec < 10) {
                        return min + ":" + "0" + sec; // 如果分大于10，秒小于10，则给秒前面加0
                    } else {
                        return min + ":" + sec; // 如果分秒都大于10，则直接return 
                    }
                }
                let hour = Number.parseInt(time / 3600); // 获取总的小时
                let min = Number.parseInt((time - hour * 3600) / 60); // 获取总分钟
                let sec = time - (hour * 3600) - (min * 60); // 减去总 分 后剩余的分秒数
                if (!hour) { // 小时为0时
                    return f_m_dispose(min, sec);
                } else { // 小时大于0的处理
                    if (!min) { // 分为0时
                        // 如果秒也小于10，则返回 例1:00:07
                        return sec < 10 ? hour + ":" + "00" + ":0" + sec : hour + ":" + "00" + ":" + sec;
                    } else { // 有分钟时的处理
                        return hour + ":" + f_m_dispose(min, sec); // 返回总小时加上处理好的分秒数
                    }
                }
            }
            // console.log(shiftTimeStamp(42000));
            // let newTime = new Date(42000).toLocaleDateString();
            function timeToMinute(times) {
                var t;
                if (times > -1) {
                    var hour = Math.floor(times / 3600);
                    var min = Math.floor(times / 60) % 60;
                    var sec = times % 60;
                    if (hour < 10) {
                        t = '0' + hour + ":";
                    } else {
                        t = hour + ":";
                    }

                    if (min < 10) {
                        t += "0";
                    }
                    t += min + ":";
                    if (sec < 10) {
                        t += "0";
                    }
                    t += sec.toFixed(2);
                }
                t = t.substring(0, t.length - 3);
                return t;
            }
            function durationTrans(a) {
                var b = ""
                var h = parseInt(a / 3600),
                    m = parseInt(a % 3600 / 60),
                    s = parseInt(a % 3600 % 60);
                if (h > 0) {
                    h = h < 10 ? '0' + h : h
                    b += h + ":"
                }
                m = m < 10 ? '0' + m : m
                s = s < 10 ? '0' + s : s
                b += m + ":" + s
                return b;
            }
            // console.log(durationTrans(127010))

            //这个不行 只能用上面的
            // let s="觥筹交错时光如梭\r\n迷失自我享受折磨\r\n这是你要的物质生活\r\n一身污浊自得其乐\r\n谁的命运谁又能把握\r\n这是种孤独没有结果\r\n精神虚伪的寄托不择手段的\r\n迷离恍惚的假想推翻不假思索\r\n如果换做是我又是何得的\r\n变作无趣的枷锁\r\n肉体诚实的反驳不合时宜的\r\n消散太快的热度假装不食烟火\r\n不由分说的我换个身份变作\r\n有趣的恶魔\r\n觥筹交错时光如梭\r\n迷失自我享受折磨\r\n这是你要的物质生活\r\n一身污浊自得其乐\r\n谁的命运谁又能把握\r\n这是种孤独没有结果\r\n精神虚伪的寄托不择手段的\r\n迷离恍惚的假想推翻不假思索\r\n如果换做是我又是何得的\r\n变作无趣的枷锁\r\n精神虚伪的寄托不择手段的 \r\n不假思索\r\n如果换做是我\r\n精神虚伪的寄托不择手段的\r\n迷离恍惚的假想推翻不假思索\r\n如果换做是我又是何得的\r\n变作无趣的枷锁\r\n肉体诚实的反驳不合时宜的\r\n消散太快的热度假装不食烟火\r\n不由分说的我换个身份变作\r\n有趣的恶魔"
            // var s = "[ti:有谁能够一夜之间长大]" +
            //     "[al:有谁能够一夜之间长大]" +
            //     "匹配时间为: 04 分 44 秒 的歌曲" +
            //     "[00:00]我爱歌词网 [www.5ilrc.com]" +
            //     "[00:00.90]有谁能够一夜之间长大 - 戊道子" +
            //     "[00:07.10]词：[盘子]" +
            //     "[00:10.99]曲：[陈绍楠]" +
            //     "[00:13.11]编曲：[SEVEN]" +
            //     "[00:17]" + "\n" +
            //     "[00:35.44][02:09]走去忘记 旧的人旧的自己" +
            //     "[00:42.60][02:16.16]远离回忆 找个人说我爱你" +
            //     "[ar:戊道子]" +
            //     "[00:49.79][02:23.22]别带着沉重去飞行" +
            //     "[00:53.31][02:26.68]别怀疑内心深处的勇气" +
            //     "[00:56.88][02:30.34]放纵地拥抱晨曦" +
            //     "[by:珍妮]" +
            //     "[01:00.16][02:33.61]在路上遇见新的自己" +
            //     "[01:06.52][03:11.60]有谁能够一夜之间长大" +
            //     "[01:13.65][03:18.93]爱情碾过还能喘气就不算差" +
            //     "[01:20.73][03:25.99]何必羡慕那不凋败的塑料花" +
            //     "[01:27.66][03:32.96]没有花期不会枯萎 难道美吗" +
            //     "[01:34.76][03:40]尽情亲吻爱情留下的疤" +
            //     "[01:41.66][03:46.96]童话也不只是有水晶鞋和白马" +
            //     "[01:49.01][03:54.40]何必为了一段插曲哭到沙哑" +
            //     "[01:55.91][04:01.08]过程不留遗憾结果也就伟大" +
            //     "[04:13.18]Lrc By：珍妮 QQ：929964514";


            if (typeof binlyric != 'object') { binlyric = {}; }
            binlyric = {
                edition: "1.1",
                obj: "",
                lyricCSS: new Object(),
                txt: "",
                index: 0,
                time: new Array(),
                lyric: new Array(),
                sort: function () { // 冒泡排序（从小到大）
                    var third;
                    for (var j = 0; j < this.index - 1; j++) {
                        for (var i = 0; i < this.index - 1; i++) {
                            if (this.time[i] > this.time[i + 1]) {
                                third = this.time[i];
                                this.time[i] = this.time[i + 1];
                                this.time[i + 1] = third;
                                third = this.lyric[i];
                                this.lyric[i] = this.lyric[i + 1];
                                this.lyric[i + 1] = third;
                            }
                        }
                    }
                },
                createPanel: function () { // 创建歌词面板
                    var i = 0;
                    $(this.obj).html("");
                    for (i = 0; i < this.index; i++) {
                        $(this.obj).append("<div>" + this.lyric[i] + "</div>");
                    }
                    for (i in this.lyricCSS) {
                        $(this.obj).find("div").css(this.lyricCSS, this.lyricCSS[i]);
                    }
                },
                findTags: function (index, strArray, number) { // 查找标签（包括任何扩展的标签）
                    // 此方法能匹配所有格式的标签
                    // 因为此方法是在后面写的，所以时间标签并没有使用此方法
                    number = number || this.txt.length;
                    number = (number > this.txt.length) ? this.txt.length : number;
                    var i, j, complete = 0, value;
                    var obj = new Object();
                    obj.booble = false;
                    obj.value = "[";
                    for (i = index; i < number; i++) {
                        if (this.txt.substr(i, 1) == strArray[complete].s) {
                            complete += 1;
                            if (complete > 1) {
                                if (complete < strArray.length) {
                                    obj.value += '{value:"' + this.txt.substr(value + 1, i - value - 1) + '"},';
                                }
                                else {
                                    obj.value += '{value:"' + this.txt.substr(value + 1, i - value - 1) + '"}]';
                                }
                            }
                            if (complete == strArray.length) {
                                obj.txt = this.txt.substr(index, i - index + 1);
                                obj.value = eval('(' + obj.value + ')');
                                obj.index = i + 1;
                                obj.booble = true;
                                break
                            }
                            value = i;
                        }
                        else if (this.txt.substr(i, 1) == "\n") {
                            obj.booble = false;
                            return obj;
                        }
                        else if (this.txt.substr(i, 1) == strArray[0].s && complete > 0) // 遇到2次开始标志就退出
                        {
                            obj.booble = false;
                            return obj;
                        }
                    }
                    return obj;
                },
                findlyric: function (index) { // 查找歌词： 有则返回 歌词、继续查找的位置， 否则只返回继续查找的位置
                    var obj = {};
                    var str = this.txt;
                    var i;
                    for (i = index; i < str.length; i++) {
                        if (str.charAt(i) == "[") {
                            var _obj = this.findTags(i, [{ s: "[" }, { s: ":" }, { s: "]" }]);
                            if (_obj.booble) {
                                obj.index = i;//i + _obj.txt.length;
                                obj.lyric = str.substr(index, i - index);
                                return obj;
                            }
                        }
                        else if (str.charAt(i) == "\n") {
                            obj.index = i + 1;
                            obj.lyric = str.substr(index, i - index);
                            return obj
                        }
                    }
                    if (i == str.length) // 专处理最后一句歌词（最后一句歌词比较特殊）
                    {
                        obj.index = i + 1;
                        obj.lyric = str.substr(index, i - index);
                        return obj;
                    }
                    obj.index = i;
                    return obj;
                },
                findTime: function (index) { // 查找时间 ： 有则返回 时间、继续查找的位置， 否则只返回继续查找的位置
                    // 此功能可以用 findTags 方法实现，更简单、更强大、代码更少
                    // findTags方法 是在后面写的，所以这里就不改了，具体可参考 findID方法里的使用实例
                    var obj = {};
                    var thisobj = this;
                    var str = this.txt;
                    obj.index = index;
                    function recursion() {
                        var _obj = thisobj.findTime(obj.index);
                        if (_obj.time) {
                            obj.time += _obj.time;
                            obj.index = _obj.index;
                        }
                    }
                    // --------------- 可以在这里 扩展 其它功能 ---------------
                    // lrc歌词只能精确到每句歌词，可以通过扩展lrc 精确 到 每个字
                    if (/\[\d{1,2}\:\d{1,2}\.\d{1,2}\]/.test(str.substr(index, 10))) // [mm:ss.ff]
                    {
                        obj.time = str.substr(index + 1, 8) + "|";
                        obj.index = index + 9 + 1;
                        recursion();
                    }
                    else if (/\[\d{1,2}\:\d{1,2}\]/.test(str.substr(index, 7))) // [mm:ss]
                    {
                        obj.time = str.substr(index + 1, 5) + ".00" + "|";
                        obj.index = index + 6 + 1;
                        recursion();
                    }
                    // 以下标签均属于合法标签，但很少被使用，请根据需要进行扩展
                    // [mm:ss.f] [mm:s.ff] [mm:s.f] [m:ss.ff] [m:s.ff] [m:s.f]
                    // [mm:s] [m:ss] [s:s]
                    return obj;
                },
                findID: function (index) { // 查找预定义标识
                    //[ar:艺人名]
                    //[ti:曲名]
                    //[al:专辑名]
                    //[by:编者（指编辑LRC歌词的人）]
                    //[offset:时间补偿值] 其单位是毫秒，正值表示整体提前，负值相反。这是用于总体调整显示快慢的。（很少被使用）
                    // 注：本程序也不支持 offset 功能（但是能取值），如需要 请自行在 sort 方法添加此功能
                    // 此处功能 使用 findTags方法 实现
                    var obj;
                    obj = this.findTags(index, [{ s: "[" }, { s: ":" }, { s: "]" }]);
                    if (obj.booble) {
                        if (obj.value[0].value == "ar") {
                            this.ar = obj.value[1].value;
                        }
                        else if (obj.value[0].value == "ti") {
                            this.ti = obj.value[1].value;
                        }
                        else if (obj.value[0].value == "al") {
                            this.al = obj.value[1].value;
                        }
                        else if (obj.value[0].value == "by") {
                            this.by = obj.value[1].value;
                        }
                        else if (obj.value[0].value == "offset") // 这里是 offset 的值
                        {
                            this.offset = obj.value[1].value;
                        }
                    }
                },
                analysis: function () { // 解析
                    if (this.txt == "") return false;
                    var str = this.txt;
                    this.index = 0;
                    for (var i = 0; i < str.length; i++) {
                        if (str.charAt(i) == "[") {
                            var time = this.findTime(i);
                            if (time.time) // 时间标签
                            {
                                var lyric = this.findlyric(time.index);
                                if (lyric.lyric != "\n" && lyric.lyric != "") // 去掉无意义歌词
                                {
                                    var timeArray = time.time.split("|");
                                    for (var j = 0; j < timeArray.length; j++) {
                                        if (timeArray[j]) {
                                            this.time[this.index] = timeArray[j];
                                            this.lyric[this.index] = lyric.lyric;
                                            this.index += 1;
                                        }
                                    }
                                }
                                i = time.index;
                            }
                            else // 预定义标签
                            {
                                this.findID(i);
                            }
                        }
                    }
                    this.sort();
                    this.createPanel();
                },
                play: function (position, CSS) { // 定位指定时间的歌词
                    var time;
                    var obj = this;
                    function set(index) {
                        var height = parseInt($(obj.obj).find("div").css("height"));
                        var top = parseInt($(obj.obj).find("div").css("margin-top"));
                        $(obj.obj).animate({
                            scrollTop: (index * height + index * top - parseInt($(obj.obj).css("height")) / 2 + height / 2)
                        }, 300);
                        for (var i in CSS) {
                            $(obj.obj).find("div").eq(index).css(CSS, CSS[i]);
                        }
                    }
                    for (var i = 0; i < this.index; i++) {
                        if (position == this.time[i]) {
                            Set(i);
                            return;
                        }
                        else if (position > this.time[i]) {
                            time = i;
                        }
                    }
                    set(time);// 没找到匹配时间 则就近最小选择
                }
            };

            binlyric.txt = s;
            binlyric.obj = ".lyricPanel";
            binlyric.lyricCSS = { "font-size": "16px", "margin-top": "15px", "text-align": "center" };
            binlyric.analysis();
            binlyric.play("01:20.22", {
                color: "red"
            });
            console.log("艺人名：" + binlyric.ar);
            console.log("专辑名：" + binlyric.al);
            console.log("歌词编者：" + binlyric.by);
            console.log("歌曲名：" + binlyric.ti);
        })(window);


    </script>
</body>

</html> -->